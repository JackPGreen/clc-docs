= clc serializer generator (Beta)

Serializer commands are a group of serializer generator operations.

For further information, see the link:https://docs.hazelcast.com/hazelcast/latest/serialization/compact-serialization[Compact Serialization] topic.

Usage:

[source,bash]
----
clc serializer [command] [flags]
----

== Commands

* <<clc-serializer-generate, clc serializer generate>>

== clc serializer generate

Generates compact serialization code from the given schema for the target language. For further information, see the link:https://docs.hazelcast.com/hazelcast/latest/serialization/compact-serialization#implementing-compactserializer[Compact Serialization] section.



Usage:

[source, bash]
----
clc serializer generate [schema] [flags]
----

Parameters:

[cols="1m,1a,2a,1a"]
|===
|Parameter|Required|Description|Default

|`output-dir`, `-o`
|Optional
|Output directory for the serialization files.
|Current working directory.

|`language`, `-l`
|Required
|Programming language for which the serializer was created.
|
|===

Example:

[source,bash]
----
clc serializer generate my-schema.yaml --language java --output-dir my-dir
----

=== Schema Creation

A schema allows you to:

* Describe the content of a compact class using supported field types
* Import other schema
* Specify namespaces for schema files and reference other namespaces
* Define cyclic references between classes
* Reference classes that are not present in the given schemas

A schema is written in YAML. The schema format is as follows:

[source,yaml]
----
namespace: <namespace of the class>
# note that other schema files can be imported with relative path to this YAML file
imports:
 - someOtherSchema.yaml
# All objects in this file will share the same namespace.
classes:
 - name: <name of the class>
   fields:
     - name: <field name>
       type: <field type>
       external: bool # to mark external types (external to this YAML file)
----

==== namespace

Used for logical grouping of classes. Typically, there is a schema file for each namespace. Namespace is optional. If not provided, the classes are generated at the global namespace. When using the namespace, you must provide the language-specific best practice. The tool uses the namespace, if provided, while generating code.

==== imports

Used to import other schema files. The type definitions in the imported YAML schemas can be used within the current YAML schema. Any cyclic imports are checked and handled. An import is restricted to a single filename. The tool assumes that all imported YAML files are in the same directory as the schema file that imports them.

==== classes

Used to define classes in the schema.

name: identifies the class being defined by name.

fields: specifies the fields used by the class, as follows:

* name: Identifies the field by name
* type: Identifies the field type. If referring to another class, use namespace.classname to identify it; if the class is defined in the same schema YAML file, you can use classname to identify it. You can specify only one type from the following:
** `boolean`
** `boolean[]`
** `int8`
** `int8[]`
** `int16`
** `int16[]`
** `int32`
** `int32[]`
** `int64`
** `int64[]`
** `float32`
** `float32[]`
** `float64`
** `float64[]`
** `string`
** `string[]`
** `date`
** `date[]`
** `time`
** `time[]`
** `timestamp`
** `timestamp[]`
** `timestampWithTimezone`
** `timestampWithTimezone[]`
** `nullableBoolean`
** `nullableBoolean[]`
** `nullableInt8`
** `nullableInt8[]`
** `nullableInt16`
** `nullableInt16[]`
** `nullableInt32`
** `nullableInt32[]`
** `nullableInt64`
** `nullableInt64[]`
** `nullableFloat32`
** `nullableFloat32[]`
** `nullableFloat64`
** `nullableFloat64[]`
** `<OtherCompactClass[]>`
* external: identifies the type as a user-defined implementation.
** The tool does not check whether external fields are imported and available. You are responsible for managing external types; they are not generated by the tool.
** Also identifies mixed use cases where the serializer of an external field is a user-written custom serializer, the zero-config serializer for Java and .NET, or was previously generated by the tool.
** In generated code, external types are imported according to the field `type`. For this reason, in languages such as Java, you must use the full package name with the class; for example, `type: com.app1.dto.Address`.